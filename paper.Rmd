---
title: "BumpyMatrix: a Bioconductor package to represent a 2-dimensional array of non-scalar objects"
tags:
  - R
  - Bioconductor
  - bioinformatics
authors:
  - name: Aaron T. L. Lun
    orcid: 0000-0002-3564-4813
    affiliation: 1
affiliations:
  - name: Genentech Inc., South San Francisco, USA
    index: 1
date: 17 January 2022
bibliography: ref.bib
---

```{r, echo=FALSE, results="hide"}
library(BiocStyle)
knitr::opts_chunk$set(error=FALSE, warning=FALSE, message=FALSE, collapse=TRUE)
set.seed(100)
```

# Introduction

Many bioinformatics workflows in the R/Bioconductor ecosystem are based on a 2-dimensional data representation where one dimension corresponds to features and the other dimension corresponds to samples.
Obvious examples of this paradigm include gene-by-sample expression matrices for transcriptome profiling experiments, peak-by-sample matrices from ChIP-seq experiments, and gene-by-cell count matrices for single-cell RNA-seq experiments.
A more sophisticated example is the `SummarizedExperiment` class, a data structure that contains any number of assay matrices, feature- and sample-level annotations as well as any additional metadata for a dataset.
The `SummarizedExperiment` is a popular representation for genomics data, serving as the cornerstone of a wide variety of analysis pipelines ranging from RNA sequencing, epigenomics, single-cell analyses and more.

However, not all types of experimental data can be easily inserted into a `SummarizedExperiment`.
The use of assay matrices assumes that each feature/sample combination has one experimental observation (or zero observations, if missing values are allowed in the matrix).
It is more difficult to store data types where each feature/sample combination is associated with multiple observations.
Our motivating example is that of a highly multiplexed RNA fluorescence _in situ_ hybridization (RNA-FISH) experiment.
Here, the features are genes, the samples are cells, and each gene/cell combination is associated with spatial coordinates for zero, one or multiple transcript molecules.

The RNA-FISH transcript coordinate data has no obvious location inside the `SummarizedExperiment`.
We cannot store it in the assays as it cannot be represented as an ordinary R matrix. 
We might consider grouping the coordinates by cell and storing them in the sample-level annotations, but this would mean that any feature-level slicing of the `SummarizedExperiment` would not be propagated to the transcript coordinates.
(And vice versa for storing them in the feature-level annotations, whereupon they would not respond to any sample-level slicing.)
This negates one of the major advantages of the `SummarizedExperiment` concept - that any operations applied to a `SummarizedExperiment` will propagate across all assays and annotations contained within,
ensuring synchronization and avoiding common book-keeping errors throughout the course of an analysis.

Here, we describe the `BumpyMatrix` class, implemented in the Bioconductor package of the same name.
This class implements a 2-dimensional array where each entry is a non-scalar object of the same type (e.g., atomic vectors, data frames) in contrast to ordinary R matrices where each entry is an atomic scalar.
An instance of a `BumpyMatrix` class can then be stored as an assay of a `SummarizedExperiment` for synchronized manipulation of the entire dataset.
We demonstrate the use of the `BumpyMatrix` for storing and manipulating some mock RNA-FISH data.
We also discuss some other bioinformatics applications that can benefit from the `BumpyMatrix` concept.

# Basic usage

To demonstrate the use of the `BumpyMatrix` class, let's mock up some data for a multiplexed RNA-FISH experiment.
Our data consists of a `DataFrame` (Bioconductor's wrapper around the base `data.frame` class) where each row contains the coordinates of a single detected transcript molecule.
We assume that demultiplexing and cell segmentation have already been performed, such that each detected molecule is also annotated with its gene identity and its cell of origin.

```{r}
library(S4Vectors)
df <- DataFrame(
    x=rnorm(10000), y=rnorm(10000), 
    gene=paste0("GENE_", sample(100, 10000, replace=TRUE)),
    cell=paste0("CELL_", sample(20, 10000, replace=TRUE))
)
df
```

We use the `splitAsBumpyMatrix()` function to create a `BumpyDataFrameMatrix`, a 2-dimensional matrix abstraction where the rows are genes and the columns are cells.
Each entry of this `BumpyDataFrameMatrix` is itself a `DataFrame` that corresponds to a particular gene/cell combination and contains the x/y-coordinates for all transcript molecules of that gene in that cell.
Each `DataFrame` may have zero, one or multiple rows, depending on the cell's expression of the gene.

```{r}
library(BumpyMatrix)
mat <- splitAsBumpyMatrix(df[,c("x", "y")], row=df$gene, column=df$cell)
mat
```

We can now manipulate `mat` in the same manner as any other matrix-like R object.
For example, we can slice by row and column, equivalent to filtering our original `df` by gene or cell respectively.

```{r}
mat[1:5,]

mat[,c("CELL_5", "CELL_10", "CELL_20")]
```

Extracting a row or column of the `BumpyDataFrameMatrix` will return a list of `DataFrame` objects, which is the 1-dimensional analogue to the atomic vectors obtained from extracting a row/column of an ordinary R matrix.
(More specifically, the return value is a Bioconductor `SplitDataFrameList`, which is used as the underlying data representation for the `BumpyDataFrameMatrix` implementation.)
A single `DataFrame` can be extracted from a `BumpyDataFrameMatrix` or a `SplitDataFrameList` with the usual `[[` operator.

```{r}
mat[1,]

mat[1,1][[1]]
```

The `lengths()` function will return the number of entries in each `DataFrame`.
In this context, the return value is a count matrix that quantifies the expression of each gene in each cell.

```{r}
counts <- lengths(mat)
counts[1:10,1:5]
```

# Compatibility with the `SummarizedExperiment`

Of particular interest is the ability to store `mat` inside Bioconductor's `SummarizedExperiment` data structure.
This allows us to synchronise the manipulations of the transcript coordinates to the rest of the dataset.

```{r}
library(SummarizedExperiment)
se <- SummarizedExperiment(list(positions = mat, counts = lengths(mat)))
se

# Limiting our analysis to the first 10 cells:
sub.se <- se[,1:10]
dim(assay(sub.se, "counts"))

# Our BumpyDataFrameMatrix is also subject to the same operation:
assay(sub.se, "positions")
```

This compatibility also simplifies the consumption of `BumpyDataFrameMatrix` assays by frameworks that operate on a `SummarizedExperiment`.
For example, the **alabaster** framework provides a mechanism for serializing R/Bioconductor objects into language-agnostic file formats, for use with other programming ecosystems like Python or Javascript.
As **alabaster** already provides a mechanism to serialize `SummarizedExperiment` objects to file, it can be easily extended to handle objects containing `BumpyDataFrameMatrix` objects in its assays.

```{r}
library(alabaster.se) # TODO: change to the alabaster umbrella.

# Saving the SummarizedExperiment into a staging directory.
staging <- tempfile()
dir.create(staging)
info <- stageObject(se, staging, "experiment_1")

# Loading the SummarizedExperiment recovers our BumpyDataFrameMatrix.
reloaded <- loadObject(info, staging)
assay(reloaded, "positions")
```

# Other `BumpyMatrix` subclasses

While we have largely focused on the `BumpyDataFrameMatrix`, the _BumpyMatrix_ package also supports other `BumpyMatrix` subclasses.
For example, the `BumpyNumericMatrix` class implements a matrix-like object where each entry is a numeric vector of any length.
To illustrate, we can generate a `BumpyNumericMatrix` instance by extracting the x-coordinates from `mat`.

```{r}
xpos <- mat[,,"x"]
xpos
```

This can be manipulated in the same manner as a `BumpyDataFrameMatrix`, except that each entry is now a numeric vector instead of a `DataFrame`.

```{r}
# Getting the x-coordinates for the first cell:
xpos[,1]

# Extracting the numeric vector directly:
xpos[1,1][[1]]
```

These `BumpyMatrix` classes can also participate in basic arithmetic, logical and mathematical operations, allowing users to perform complex manipulations in an intuitive manner.
Imagine that we have the centroid for each cell, and we wish to compute the distance of each transcript from its cell's centroid.
We can achieve this by applying the usual formula for a 2-dimensional Euclidean distance on our `BumpyNumericMatrix` objects.

```{r}
# Mocking up a centroid x/y coordinate for each cell.
x_cell <- rnorm(ncol(mat))
y_cell <- rnorm(ncol(mat))

# Computing the Euclidean distance of each transcript from the centroid.
# Transpositions ensure that the cell centroid coordinates are recycled along
# the cells, not along the features.
squared_x <- (t(mat[,,"x"]) - x_cell)^2 
squared_y <- (t(mat[,,"y"]) - y_cell)^2
dist <- t(sqrt(squared_x + squared_y))
dist
```

Further imagine that we wish to filter `mat` to remove transcripts that are more than, say, 2 units away from the centroid.
This is possible by converting our `BumpyNumericMatrix` into a `BumpyLogicalMatrix` via the usual logical `<` operation.
The resulting `BumpyLogicalMatrix` can then be used to subset our original `BumpyDataFrameMatrix`, which will apply the filter of the former to the rows of each individual `DataFrame` in the latter.

```{r}
keep <- dist <= 2
keep

# We can use a BumpyLogicalMatrix as a index into the BumpyDataFrameMatrix.
filtered <- mat[keep]
filtered
```

# Examples of other applications

# References

